{
  "name": "stations",
  "version": "0.2.0",
  "description": "Pub/sub event bus",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "pub/sub",
    "radio",
    "channels",
    "events",
    "event",
    "bus"
  ],
  "author": {
    "name": "tunderdomb"
  },
  "license": "MIT",
  "readme": "stations\r\n========\r\n\r\nIt's a radio!\r\nUse this to include an app level event bus into your app.\r\n\r\nProviders are baked in \"messages\".\r\nThey can be used to register persistent logic and provide/request them.\r\nLike app settings or app level constant/static methods.\r\n\r\nMessages can be cancelled, which stops propagation.\r\nIf a message is cancelled, no other listeners will reach it.\r\n\r\n\r\n```js\r\nvar stations = require(\"stations\")\r\n\r\n// the module exports a function that returns a Radio instance\r\nradio = stations(\"\")\r\n\r\n// constructors are exposed for inheritance\r\nvar radio = new stations.Radio(\"\")\r\nvar channel = new stations.Channel(\"\")\r\nvar message = new stations.Message({})\r\n\r\n```\r\n\r\n## Radio\r\n\r\n```js\r\nvar radio = stations(\"name\")\r\n```\r\n\r\n#### `name`\r\n\r\n**type** `String` The radio's name (optional)\r\n\r\n```js\r\nradio.name\r\n```\r\n\r\n#### channelExists( *String* `channel` )\r\n\r\n**return** `boolean` true if the channel is registered\r\n\r\n`channel` the channel name to check\r\n\r\n```js\r\nradio.channelExists(\"\")\r\n```\r\n\r\n#### createChannel( *String* `channel` )\r\n\r\n**return** `Channel` the channel instance created\r\n\r\n`channel` the channel name\r\n\r\n```js\r\nvar channel = radio.createChannel(\"\")\r\n```\r\n\r\n#### deleteChannel( *String* `channel` )\r\n\r\n**return** `boolean` true if the channel was deleted,\r\n                     false if it never existed before\r\n\r\n`channel` the channel name to delete\r\n\r\n```js\r\nradio.deleteChannel(\"\")\r\n```\r\n\r\n#### publish( *String* `channel`, *Object* `content` )\r\n\r\n**return** `Message` the message object passed to listeners\r\n\r\n`channel` the channel to broadcast the message\r\n\r\n`content` any content\r\n\r\n```js\r\nvar message = radio.publish(\"\", {})\r\n```\r\n\r\n#### subscribe( *String* `channel`, *Function* `listener` )\r\n\r\n**return** `Radio` the radio instance this method was called on (`this`)\r\n\r\n`channel` the channel to subscribe\r\n\r\n`listener` the callback to call on messages.\r\n           Listeners receive a `Message` object as the only argument\r\n\r\n```js\r\nradio.subscribe(\"\", function listener( message ){\r\n  // ...\r\n})\r\n```\r\n\r\n#### unsubscribe( *String* `channel`, *Function* `listener` )\r\n\r\n**return** `Radio` the radio instance this method was called on (`this`)\r\n\r\n`channel` the channel to unsubscribe\r\n\r\n`listener` the listener to unsubscribe\r\n\r\n```js\r\nradio.unsubscribe(\"\", listener)\r\n```\r\n\r\n#### peek( *String* `channel`, *Function* `listener` )\r\n\r\nPeek into a channel once and unsubscribe from it immediately.\r\n\r\n**return** `Radio` the radio instance this method was called on (`this`)\r\n\r\n`channel` the channel to peek into\r\n\r\n`listener` the listener to call on `publish()`.\r\n           Listeners receive a `Message` object as the only argument\r\n\r\n```js\r\nradio.peek(\"\", function( message ){\r\n  // will execute only once, when `publish()` is called\r\n})\r\n```\r\n\r\n## Providers\r\n\r\n#### providerExists( *String* `name` )\r\n\r\n**return** `boolean` true if the provider exists\r\n\r\n`name` the provider name to check\r\n\r\n```js\r\nradio.providerExists(\"\")\r\n```\r\n\r\n#### provide( *String* `name`, *Function* `provider` )\r\n\r\n**return** `undefined`\r\n\r\n`name` the provider name\r\n\r\n`provider` the provider function to store\r\n\r\n```js\r\nradio.provide(\"\", function provider( ... ){\r\n  // ...\r\n})\r\n```\r\n\r\n#### request( *String* `name` )\r\n\r\n**return** `Function` the requested provider\r\n\r\n`name` the provider to request\r\n\r\n```js\r\nvar provider = channel.request(\"\")\r\nprovider(...)\r\n```\r\n\r\n\r\n## Channel\r\n\r\n```js\r\nvar channel = radio.createChannel(\"\")\r\n```\r\n\r\nChannels are array instances and you can use array methods on them.\r\n\r\n```js\r\nchannel instanceOf Array === true\r\n```\r\n\r\n#### publish( *Object* `content` )\r\n\r\n**return** `Message` the message passed to listeners\r\n\r\n`content` any content\r\n\r\n```js\r\nchannel.publish({})\r\n```\r\n\r\n#### subscribe( *Function* `listener` )\r\n\r\n**return** `Channel` the Channel instance this method was called on (`this`)\r\n\r\n`listener` the callback to call on messages.\r\n           Listeners receive a `Message` object as the only argument\r\n\r\n```js\r\nchannel.subscribe(function( message ){\r\n  // ...\r\n})\r\n```\r\n\r\n#### unsubscribe( *Function* `listener` )\r\n\r\n**return** `Channel` the Channel instance this method was called on (`this`)\r\n\r\n`listener` the callback to call on messages\r\n\r\n```js\r\nchannel.unsubscribe(listener)\r\n```\r\n\r\n#### peek( *Function* `listener` )\r\n\r\nPeek into the channel once and unsubscribe from it immediately.\r\n\r\n**return** `Channel` the Channel instance this method was called on (`this`)\r\n\r\n`listener` the listener to call on `publish()`.\r\n           Listeners receive a `Message` object as the only argument\r\n```js\r\nradio.peek(\"\", function( message ){\r\n  // will execute only once, when `publish()` is called\r\n})\r\n```\r\n\r\n## Message\r\n\r\nMessages are passed to listeners and wrap the data they carry.\r\n\r\n#### `content`\r\n\r\n**type** `any` the content passed to `publish(...)`\r\n\r\n```js\r\nmessage.content\r\n```\r\n\r\n#### `cancelled`\r\n\r\n**type** `boolean` true if the message was cancelled\r\n\r\n```js\r\nmessage.cancelled\r\n```\r\n\r\n#### cancel(  )\r\n\r\n**return** `undefined`\r\n\r\n```js\r\nradio.subscribe(\"\", function listener( message ){\r\n  message.cancel()\r\n})\r\n```\r\n\r\n",
  "readmeFilename": "README.md",
  "_id": "stations@0.2.0",
  "_from": "stations@"
}
